import { SIGTYPE } from '@lit-protocol/constants';
import type { AuthSig, CustomNetwork, FormattedMultipleAccs, HandshakeWithNode, JsonHandshakeResponse, LitNodeClientConfig, MultipleAccessControlConditions, NodeCommandServerKeysResponse, RejectedNodePromises, SendNodeCommand, SessionSig, SessionSigsMap, SuccessNodePromises, SupportedJsonRequests } from '@lit-protocol/types';
export declare type LitNodeClientConfigWithDefaults = Required<Pick<LitNodeClientConfig, 'bootstrapUrls' | 'alertWhenUnauthorized' | 'debug' | 'connectTimeout' | 'checkNodeAttestation' | 'litNetwork' | 'minNodeCount' | 'retryTolerance'>> & Partial<Pick<LitNodeClientConfig, 'storageProvider' | 'contractContext'>>;
export declare class LitCore {
    config: LitNodeClientConfigWithDefaults;
    connectedNodes: Set<string>;
    serverKeys: Record<string, JsonHandshakeResponse>;
    ready: boolean;
    subnetPubKey: string | null;
    networkPubKey: string | null;
    networkPubKeySet: string | null;
    hdRootPubkeys: string[] | null;
    latestBlockhash: string | null;
    lastBlockHashRetrieved: number | null;
    private _networkSyncInterval;
    private _epochUpdateTimeout;
    private _stakingContract;
    private _stakingContractListener;
    private _connectingPromise;
    private _epochCache;
    constructor(config: LitNodeClientConfig | CustomNetwork);
    getLogsForRequestId: (id: string) => string[];
    /**
     * Asynchronously updates the configuration settings for the LitNodeClient.
     * This function fetches the minimum node count and bootstrap URLs for the
     * specified Lit network.
     *
     * It validates these values and updates the client's
     * configuration accordingly.
     *
     * It also stashes a handle on the Staking Contract so that we can use it for polling for epoch-related state changes
     *
     * @throws Will throw an error if the minimum node count is invalid or if
     *         the bootstrap URLs array is empty.
     * @returns {Promise<void>} A promise that resolves when the configuration is updated.
     */
    setNewConfig: () => Promise<void>;
    /** Schedule an update to the current epoch number for EPOCH_PROPAGATION_DELAY seconds from now
     * We don't immediately update this value on `NextValidatorSetLocked` state changes because we want to give the nodes
     * a few seconds to update to the new epoch before we start sending the new epoch number with requests
     *
     * This function should only be called as a result of a rare state change (`NextValidatorSetLocked`)
     * So we don't debounce setting the timeout handler.
     * @private
     */
    private _scheduleEpochNumberUpdate;
    private _handleStakingContractStateChange;
    /**
     * Sets up a listener to detect state changes (new epochs) in the staking contract.
     * When a new epoch is detected, it triggers the `setNewConfig` function to update
     * the client's configuration based on the new state of the network. This ensures
     * that the client's configuration is always in sync with the current state of the
     * staking contract.
     *
     * @returns {Promise<void>} A promise that resolves when the listener is successfully set up.
     */
    private _listenForNewEpoch;
    /**
     *  Stops internal listeners/polling that refresh network state and watch for epoch changes
     */
    disconnect(): Promise<void>;
    _stopNetworkPolling(): void;
    _stopListeningForNewEpoch(): void;
    /**
     *
     * Set bootstrapUrls to match the network litNetwork unless it's set to custom
     *
     * @returns { void }
     *
     */
    setCustomBootstrapUrls: () => void;
    /**
     * Return the latest blockhash from the nodes
     * @returns { Promise<string> } latest blockhash
     */
    getLatestBlockhash: () => Promise<string>;
    /**
     *
     * Connect to the LIT nodes
     *
     * @returns { Promise } A promise that resolves when the nodes are connected.
     *
     */
    connect(): Promise<void>;
    private _connect;
    private handshakeAndVerifyNodeAttestation;
    /** Handshakes with all nodes that are in `bootstrapUrls`
     * @private
     *
     * @returns {Promise<{connectedNodes: Set<string>, serverKeys: {}}>} Returns a set of the urls of nodes that we
     * successfully connected to, an object containing their returned keys, and our 'core' config (most common values for
     * critical values)
     */
    private _runHandshakeWithBootstrapUrls;
    private _getCoreNodeConfigFromHandshakeResults;
    /** Currently, we perform a full sync every 30s, including handshaking with every node
     * However, we also have a state change listener that watches for staking contract state change events, which
     * _should_ be the only time that we need to perform handshakes with every node.
     *
     * However, the current block hash does need to be updated regularly, and we currently update it only when we
     * handshake with every node.
     *
     * We can remove this network sync code entirely if we refactor our code to fetch latest blockhash on-demand.
     * @private
     */
    private _scheduleNetworkSync;
    /**
     *
     * Get a random request ID
     *
     * @returns { string }
     *
     */
    getRequestId(): string;
    /**
     *
     * Get a random hex string for use as an attestation challenge
     *
     * @returns { string }
     */
    getRandomHexString(size: number): string;
    /**
     * Handshake with Node
     *
     * @param { HandshakeWithNode } params
     * @param { string } requestId
     * @returns { Promise<NodeCommandServerKeysResponse> }
     *
     */
    handshakeWithNode: (params: HandshakeWithNode, requestId: string) => Promise<NodeCommandServerKeysResponse>;
    private fetchCurrentEpochNumber;
    get currentEpochNumber(): number | null;
    set currentEpochNumber(epochNumber: number | null);
    /**
     *
     * Send a command to nodes
     *
     * @param { SendNodeCommand }
     *
     * @returns { Promise<any> }
     *
     */
    sendCommandToNode: ({ url, data, requestId, }: SendNodeCommand) => Promise<any>;
    /**
     *
     * Get and gather node promises
     *
     * @param { any } callback
     *
     * @returns { Array<Promise<any>> }
     *
     */
    getNodePromises: (callback: (url: string) => Promise<any>) => Promise<any>[];
    /**
     *
     * Get either auth sig or session auth sig
     *
     */
    getSessionOrAuthSig: ({ authSig, sessionSigs, url, mustHave, }: {
        authSig?: AuthSig | undefined;
        sessionSigs?: SessionSigsMap | undefined;
        url: string;
        mustHave?: boolean | undefined;
    }) => AuthSig | SessionSig;
    validateAccessControlConditionsSchema: (params: MultipleAccessControlConditions) => Promise<boolean>;
    /**
     *
     * Get hash of access control conditions
     *
     * @param { MultipleAccessControlConditions } params
     *
     * @returns { Promise<ArrayBuffer | undefined> }
     *
     */
    getHashedAccessControlConditions: (params: MultipleAccessControlConditions) => Promise<ArrayBuffer | undefined>;
    /**
     * Handle node promises
     *
     * @param { Array<Promise<any>> } nodePromises
     *
     * @param { string } requestId requestId to be logged in case of error
     * @param { number } minNodeCount number of nodes we need valid results from in order to resolve
     * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
     */
    handleNodePromises: <T>(nodePromises: Promise<T>[], requestId: string, minNodeCount: number) => Promise<SuccessNodePromises<T> | RejectedNodePromises>;
    /**
     *
     * Throw node error
     *
     * @param { RejectedNodePromises } res
     *
     * @returns { void }
     *
     */
    _throwNodeError: (res: RejectedNodePromises, requestId: string) => void;
    /**
     *
     * Get different formats of access control conditions, eg. evm, sol, unified etc.
     *
     * @param { SupportedJsonRequests } params
     *
     * @returns { FormattedMultipleAccs }
     *
     */
    getFormattedAccessControlConditions: (params: SupportedJsonRequests) => FormattedMultipleAccs;
    /**
     * Calculates an HD public key from a given keyId
     * The curve type or signature type is assumed to be k256 unless provided
     * @param keyId
     * @param {SIGTYPE} sigType
     * @returns {string} public key
     */
    computeHDPubKey: (keyId: string, sigType?: SIGTYPE) => string;
    /**
     * Calculates a Key Id for claiming a pkp based on a user identifier and an app identifier.
     * The key Identifier is an Auth Method Id which scopes the key uniquely to a specific application context.
     * These identifiers are specific to each auth method and will derive the public key portion of a pkp which will be persisted
     * when a key is claimed.
     * | Auth Method | User ID | App ID |
     * |:------------|:--------|:-------|
     * | Google OAuth | token `sub` | token `aud` |
     * | Discord OAuth | user id | client app identifier |
     * | Stytch OTP |token `sub` | token `aud`|
     * | Lit Actions | user defined | ipfs cid |
     * *Note* Lit Action claiming uses a different schema than other auth methods
     *
     * @param {string} userId user identifier for the Key Identifier
     * @param {string} appId app identifier for the Key Identifier
     * @param {boolean} isForActionContext should be set for true if using claiming through actions
     *
     * @returns {string} public key of pkp when claimed
     */
    computeHDKeyId(userId: string, appId: string, isForActionContext?: boolean): string;
}
